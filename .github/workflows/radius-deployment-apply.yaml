# Radius deployment workflow
# Generated by rad init - do not edit manually
#
# CUSTOMIZATION GUIDE:
#
# To trigger after deployment create completes (CI/CD pipeline):
#
#   on:
#
#     workflow_run:
#
#       workflows: ['Radius deployment create']
#
#       types: [completed]
#
# 
#
# To trigger on merge to main (after PR review of the plan):
#
#   on:
#
#     push:
#
#       branches: [main]
#
#       paths: ['.radius/deploy/**']
#
# 
#
# To require approval before applying, configure GitHub Environment
#
# protection rules with required reviewers.
#
# 
#
# GitHub Secrets are available in steps via ${{ secrets.SECRET_NAME }}

name: Radius deployment apply
run-name: Radius deployment apply for ${{ inputs.application }} in ${{ inputs.environment }} environment
"on":
    workflow_dispatch:
        inputs:
            application:
                description: Application name
                required: true
                type: string
            commit:
                description: Git commit hash identifying the deployment plan to apply
                required: true
                type: string
            environment:
                description: Target GitHub Environment name
                required: true
                type: string
permissions:
    actions: read
    contents: write
    id-token: write
concurrency:
    group: radius-${{ inputs.application }}-${{ inputs.environment }}
jobs:
    apply:
        name: Apply Deployment Plan
        runs-on: ubuntu-latest
        environment: ${{ inputs.environment }}
        steps:
            - name: Checkout Radius source
              uses: actions/checkout@v4
              with:
                path: radius-src
                ref: ${{ vars.RADIUS_REF || 'main' }}
                repository: ${{ vars.RADIUS_REPO || 'radius-project/radius' }}
            - name: Setup Go
              uses: actions/setup-go@v5
              with:
                cache: "true"
                go-version-file: radius-src/go.mod
            - name: Build Radius CLI
              run: cd radius-src && go build -o /usr/local/bin/rad ./cmd/rad
            - name: Checkout application repository
              uses: actions/checkout@v4
              with:
                path: app
            - name: Clone resource types repository
              run: |-
                # Parse RADIUS_RESOURCE_TYPES_REPO URL (format: https://github.com/<owner>/<repo>/tree/<branch>)
                REPO_PATH=$(echo "$RADIUS_RESOURCE_TYPES_REPO" | sed 's|https://github.com/||' | sed 's|/tree/.*||')
                BRANCH=$(echo "$RADIUS_RESOURCE_TYPES_REPO" | sed 's|.*/tree/||')

                git clone --depth 1 --branch "$BRANCH" "https://github.com/${REPO_PATH}.git" resource-types

                # Copy bicepconfig.json and Bicep extension archives to app directory
                # so rad deploy can resolve Bicep extensions (Bicep searches parent dirs from .bicep file)
                cp resource-types/default-config/bicepconfig.json app/
                cp resource-types/default-config/*.tgz app/
              env:
                RADIUS_RESOURCE_TYPES_REPO: ${{ vars.RADIUS_RESOURCE_TYPES_REPO }}
            - name: Install k3d
              run: curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash
            - name: Create k3d cluster
              run: k3d cluster create radius-ephemeral --volume $GITHUB_WORKSPACE/app:/github_workspace
            - name: Export kubeconfig
              run: k3d kubeconfig get radius-ephemeral > /tmp/kubeconfig.yaml
            - name: Install Radius control plane
              run: cd app && rad install kubernetes --skip-contour-install --set dashboard.enabled=false ${RADIUS_IMAGE_REGISTRY:+--set global.imageRegistry=$RADIUS_IMAGE_REGISTRY} ${RADIUS_IMAGE_TAG:+--set global.imageTag=$RADIUS_IMAGE_TAG}
              env:
                KUBECONFIG: /tmp/kubeconfig.yaml
                RADIUS_IMAGE_REGISTRY: ${{ vars.RADIUS_IMAGE_REGISTRY }}
                RADIUS_IMAGE_TAG: ${{ vars.RADIUS_IMAGE_TAG }}
            - name: Wait for Radius and create resource group
              run: |-
                echo "Waiting for Radius control plane to be ready..."
                for i in $(seq 1 30); do
                  if rad group create github 2>/dev/null; then
                    echo "Radius control plane is ready, resource group created."
                    exit 0
                  fi
                  echo "Control plane not ready yet, retrying in 5s... ($i/30)"
                  sleep 5
                done
                echo "Timed out waiting for Radius control plane"
                exit 1
              env:
                KUBECONFIG: /tmp/kubeconfig.yaml
            - name: Register resource types
              run: |-
                cd resource-types/default-config
                for def_file in $(yq -r '.types[].definitionLocation' types.yaml); do
                  echo "Registering resource type from $def_file..."
                  rad resource-type create --from-file "$def_file"
                done
              env:
                KUBECONFIG: /tmp/kubeconfig.yaml
            - name: Create environment
              run: rad env create ${{ inputs.environment }} --group github
              env:
                KUBECONFIG: /tmp/kubeconfig.yaml
            - name: Register recipes
              run: |-
                if [ -z "$RADIUS_RECIPES_MANIFEST" ]; then
                  echo "No RADIUS_RECIPES_MANIFEST configured, skipping recipe registration"
                  exit 0
                fi
                curl -fsSL "$RADIUS_RECIPES_MANIFEST" -o /tmp/recipes-manifest.yaml
                echo "Registering recipes from manifest..."
                # Iterate over top-level keys that have recipeKind (skip comment-only keys like 'recipes')
                for resource_type in $(yq e 'keys | .[]' /tmp/recipes-manifest.yaml); do
                  kind=$(yq e ".\"${resource_type}\".recipeKind // \"\"" /tmp/recipes-manifest.yaml)
                  if [ -z "$kind" ] || [ "$kind" = "null" ]; then
                    continue
                  fi
                  location=$(yq e ".\"${resource_type}\".recipeLocation" /tmp/recipes-manifest.yaml)
                  echo "  Registering $resource_type ($kind)..."
                  # Use full environment ID to ensure correct scope
                  rad recipe register default \
                    --resource-type "$resource_type" \
                    --template-kind "$kind" \
                    --template-path "$location" \
                    --environment "/planes/radius/local/resourceGroups/github/providers/Applications.Core/environments/${{ inputs.environment }}" || echo "  Warning: Failed to register $resource_type, will use fallback"
                done
                echo "Recipe registration complete"
              env:
                KUBECONFIG: /tmp/kubeconfig.yaml
                RADIUS_RECIPES_MANIFEST: ${{ vars.RADIUS_RECIPES_MANIFEST }}
            - name: Configure cloud credentials
              id: auth
              run: |-
                # Detect provider from environment variables
                if [ -n "$AZURE_CLIENT_ID" ]; then
                  echo "provider=azure" >> $GITHUB_OUTPUT
                elif [ -n "$AWS_IAM_ROLE_NAME" ]; then
                  echo "provider=aws" >> $GITHUB_OUTPUT
                else
                  echo "No cloud provider credentials found in environment"
                  exit 1
                fi
              env:
                AWS_IAM_ROLE_NAME: ${{ vars.AWS_IAM_ROLE_NAME }}
                AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
            - name: Azure Login
              uses: azure/login@v2
              with:
                client-id: ${{ vars.AZURE_CLIENT_ID }}
                subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}
                tenant-id: ${{ vars.AZURE_TENANT_ID }}
              if: steps.auth.outputs.provider == 'azure'
            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                aws-region: ${{ vars.AWS_REGION }}
                role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/${{ vars.AWS_IAM_ROLE_NAME }}
              if: steps.auth.outputs.provider == 'aws'
            - name: Apply deployment plan
              run: |-
                cd app
                # Use short commit hash (7 chars) for directory path matching deployment-create
                SHORT_COMMIT="${COMMIT_HASH:0:7}"
                PLAN_DIR=".radius/deploy/${{ inputs.application }}/${{ inputs.environment }}/${SHORT_COMMIT}"

                if [ ! -d "$PLAN_DIR" ]; then
                  echo "Error: No deployment plan found at $PLAN_DIR"
                  echo "Run 'rad deployment create' first to generate a plan."
                  exit 1
                fi

                # Apply deployment using the existing plan
                rad deploy ".radius/applications/${{ inputs.application }}.bicep" \
                  --application "${{ inputs.application }}" \
                  --environment "${{ inputs.environment }}" \
                  --group github \
                  --apply "$PLAN_DIR"
              env:
                COMMIT_HASH: ${{ inputs.commit }}
                KUBECONFIG: /tmp/kubeconfig.yaml
            - name: Record deployment results
              run: |-
                cd app
                SHORT_COMMIT="${COMMIT_HASH:0:7}"
                PLAN_DIR=".radius/deploy/${{ inputs.application }}/${{ inputs.environment }}/${SHORT_COMMIT}"

                git config user.name "github-actions[bot]"
                git config user.email "github-actions[bot]@users.noreply.github.com"
                git add "$PLAN_DIR/"
                git commit -m "Deployment results for ${{ inputs.application }} in ${{ inputs.environment }} at ${SHORT_COMMIT}" \
                  --trailer "Radius-Action: deployment-apply" || true
                git fetch origin ${{ github.ref_name }}
                git rebase FETCH_HEAD
                git push origin HEAD:${{ github.ref_name }}
              env:
                COMMIT_HASH: ${{ inputs.commit }}
              if: always()
